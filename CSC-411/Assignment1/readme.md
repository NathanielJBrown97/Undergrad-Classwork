**Rust Assignment 1: Readme Document**  
**Programming Partners:** Nathaniel Brown, Jake Dansereau  

**Acknowledgement of Help:** Outside of working through particular problems with syntax and familarizing ourselves with a new language amongst the group partners; the majority of our outside help came from Teaching Assistants. In particular; Vincent Zhuang(x4), Nicholas(x1), Emily Light(x1), and Ayman Sandouk(x1).  

**__Vincent__** - Extremely helpful with clarification of some of the objectives of the assignment that caused confusion, as well as explaining core concepts of rust that are similar, but yet different from rust. As well as providing some supplementary background information on hashmaps in general that my group was rather weak with fully understanding before this assignment.  

**__Nicholas__** - Extremely helpful with instructing me how to properly look through the documentation of Rust, but more in particular the documentation of the 411csc_image module. Helped clarify things relating to the Gray type that was contained within the pixels vector, that caused a major barrier to the brightness assignment. Also provided some background information on error handling with the options system related to rust.  

**__Emily__** - Extremely helpful with providing supplementary information in the form of a mini-lecture with my group and other members of the 411 class in the Tyler lonuge. Helped provide a much better understanding of result, in particular options (some/none).  

**__Ayman__** - Extremely helpful with helping guide me towards better ways to troubleshoot my code when grade scope does not provide test cases that get me to the finish line. Instead; he proposed methodologies that could be used to find those issues on my own. (Which immediately lead to the detection of a major flaw in an earlier version of my program.)  
  
**Correctly implementation:**  
For Brightness: Everything was fully implemented. We wrote error checking conditionals for incorrect arguments, and checked whether the promised file was of type Gray, not RGB or other types.  
  
For Fingerprint Groups: Mostly everything was implemented. We implemented a feature that will read a line; taking the first sequence of characters as a key that we called fingerprint, and all other characters after the first whitespace as a value we called name. This was the first step of implementing the entire assignment. From here we then implemented some logic using rusts 'match' that checks if there is already a key in the hashmap with the current fingerprint identifier. If so, it pushes the name into that key's association. If the key wasn't found, then it simply inserts the key:value (fingerprint:name) into the hashmap. This was our method of properly sorting the data. Rather than collect it all and then sort it, simply sort it during the collection. To handle the specifications of only printing fingerprint groups that have more than 1 name associated with their fgroup type; we used a for loop that iterates through the keys of the hashmap (fingerprints) and checks if there is more than 1 name within the associated values. If so, then it would iterate through those values and seperate them by new lines. This satisified the requirements of binary fingerprints on gradescope.  
  
**What was not fully implemented: **  
For Fingerprint Groups: We failed to pass the 'Large Input' section of gradescope. I have yet to identify what exactly is causing the output to not match the test case. As I cannot see the test case, I have been making large txt files and trying different variations of input to try and identify any inconsistencies that do not match my intended output. After failing to identify any issues on entries with upwards of 100-150 varying key:values. I reread through the PDF to try and find some specification that was overlooked; initially I thought it could have been due to name entries exceeding 500+ characters, but after further clarification from a TA determined that that could not be the case. As my program opted out of truncating large name entries ('as suggested by the instructions; simplest is best'). I'm very curious as to what is causing this test case fail, but have yet to find out what it is.  

  
**PART C:** Problems you can solve using a working version of fgroups **:PART C**  
   
**1.)** Support Tickets; suppose a fictitious company has a support department where customers are able to submit tickets for support from the company. Naturally some issues will have greater importance than others. If tickets were submitted with a 'Priority' label indiciating whether it is High, Medium, or Low urgency. Followed by an 'Issue Identifier' which could be selected or filled out from the user. You would effectively sort your issues into a hashmap containing keys (the level of urgency) and values (issues within each urgency group). This could easily be implemented with the fgroups program; although it could be expanded by changing our names:values to an object that contains more prevelant member variables and information to the Issue submitted in this fictitious company.  
  
**2.)** Library Management; perhaps a library wishes to actually know what inventory they have. Rather than just have a giant disorganized collection of all books within their collection. You can have books sorted by Genres, which would be our keys, and Books, which would be our values. After reading a giant file containing all of the books and associating them with a genre identifier. The library would now have access to every book in their collection, organized by genre. This would easily be implemented using the fgroups program as it stands currently; again it could be expanded though. Perhaps by expanding the program to include a basic user interface, in which the user could search for a specific book and have returned the genre it's categorized under.  
  
**3.)**
